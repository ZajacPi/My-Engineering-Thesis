\chapter{Electrical design of the robot}
\label{cha:elektronika}

\section{Servomotors and PCA9685 module}
\subsection{Servomotors}
Charakterystyka serw (zakres 180°)

Wymagania momentowe dla osi ( tu torque analysis)
Zależność momentu od napięcia
Prądy w najgorszym przypadku

\subsection{PCA9685 module}
Dlaczego RPi nie generuje PWM stabilnie, i dlaczego lepiej to oddelegować 
Zalety PCA9685 (16 kanałów, I2C, 12-bit resolution)
Umieszczenie modułu na obrotowej podstawie + slip ring
Wymagania napięciowe (5 V logic, 6/7.4 V power)

Do ruchu osiami zastosowano serwonapędy 180 stopni, które ustawiają kąt orczyka na podstawie wypełnienia sygnału PWM dostarczonego na ich wejście. \\
Raspberry pi nie jest dobre do generowania dobrego sygnału PWM, a co dopiero pięciu. Dlatego serwonapędy są sterowane przy pomocy modułu PCA9685, który generuje sygnały PWM na wszystkich serwonapędach jednocześnie i komunikuje się z Raspberry Pi przez protokół I2C.\\
Dodatkowo pozwala to na umiejscowienie modułu PCA9685 w obracającej się części podstawy i przeprowadzenie przez slip ring jedynie 4 przewodów: 2 zasilające, 2 do I2C.

Serwonapędy osi 2, 3 i 4 przy zasilaniu napięciem 7,4V pozwalają uzyskać z nich maksymalny moment siły, natomiast ostatnie dwa serwonapędy są obsługiwane napięciem 6V. Dodatkowo, sterownik PCA9685 przyjmuje napięcie 5V. W takim wypadku należy zamocować regulator napięcia Buck Converter, który zmniejsza napięcie z małymi stratami energii do 6V, natomiast do PCA9685 dodatkowo zamontować regulator liniowy LM7805 zmniejszający napięcie do 5V.

\section{Stepper motor}
Model JK42HS48-1204
Wymagania prądowe
Sterownik DRV8825 – napięcia, prąd, mikro-kroki
Dlaczego Raspberry Pi nie nadaje się (lack of real-time)
Testy na prototypowej płytce
A3144 Hall sensor for homing

Do poruszania pierwszą osią zastosowano silnik krokowy JK42HS48-1204, który kontrolowany jest przy pomocy sterownika serwonapędu DRV8825. 
Probem jest taki, że Raspberry pi nie nadaje się do generowania dobrego sygnału sterującego silnikiem krokowym, ponieważ raspberry pi z systemem linux nie jest systemem real time. Próby sterowania silnika krokowego przez Raspberry pi zakończyły się porażką, silnik wydawał tylko wysokie piskliwe dźwięki. 
W takich wypadkach, stosuje się połączenie mikroprocesora jakim jest raspberry z mikrokontrolerem. Do tego służy micro-ros. W moim projekcie użyję ESP32, potężnego mikrokontrolera zawierającego moduł bluetooth i wifi.

Stworzono płytkę prototypową w której połączono ESP ze sterownikiem. Sterownik należało nastroić do pracy z 12V (9V nie zadziałało) tak, żeby pomiędzy potencjometrem a masą było napięcie o wartości dwukrotnie niższej niż natężenie silnika. Wykonano testy, wszystko śmigało, następnie spróbowano wgrać microros i sterować silnikiem przez raspberry

Silnik krokowy wymaga bazowania przy starcie aby zapewnić poprawną orientację robota. Do tego wykorzystano magnes oraz cyfrowy czujnik halla A3144, który na wyjściu daje stan wysoki przy pojawieniu się pola magnetycznego. 

\section{ESP32 microcontroller with microROS}
Rola ESP32 jako warstwa real-time

Połączenie z DRV8825 i PCA9685

Komunikacja z ROS2 przez microROS agent

UART/WiFi options

Do generowania sygnału I2C oraz poprawnie sterować sterownikiem silnika krokowego dobrą praktyką jest użycie mikrokontrolera. W projekcie zdecydowano się na użycie ESP32, które poza komunikacją przez przewód umożliwia komunikację przez WiFi. Dodatkowo ESP32 posiada wystaczająco dużo pamięci oraz jest oficjalnie wspierane przez MicroROS. Jest to narzędzie pozwalające na połączenie mikrokontrolera z projektem ROS2, łącząc się przez tzw. microros_agent, który działa na mikroprocesorze z projektem ROS2.


\section{Powering the system}
W projekcie znajdują się elementy wymagające różnych napięć: 
\begin{itemize}
    \item Silnik krokowy: 12V
    \item Wentylator: 12V
    \item Serwomechanizmy 25kg*cm: 7,4V
    \item Serwomechanizmy 9g: 6V
    \item PCA9685: 5V
    \item DRV8825: 3.3V
    \item ESP32: 5V
\end{itemize}
(wstawić poprawione obliczenia)\\
Serwonapędy w najgorszym wypadku 3,5A, ale skoro pierwszy silnik się zatnie przy jakiejś masie to można policzyć ile wtedy będzie miało kolejne serwo, bo przecież ma o wiele krótsze ramię, i kolejne jeszcze krótsze, więc mogę oszacować ile w najgorszym przypadku będzie pobierać prądu. 
Mam 3 duże serwa pobierające 3,5A, dwa małe pobierające najgorzej 750mA, i silnik krokowy 1,2A. Więc najgorzej około 5,5A. Więc w najgorszym wypadku serwa będą pobierać 4,3A. Więc potrzebuję regulatora napięcia który zbije 12V do 7,4V do serwonapędów i wytrzyma 4,3A. Buck converter też zwiększy ampery. Więc 12V * xA = 7,4V x 12A, czyli x=7,4A, więc teoretycznie zasilacz 12V 8A jest jeszcze z małym zapasem.
Wniosek: Zasilacz 12V 10A powinien starczyć

\section{Schemat elektroniczny całego robota}
Buck converter, Czym jest, jak działa, jaka sprawność, czy podbija natężenie. 






